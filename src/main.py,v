head	1.2;
access;
symbols;
locks; strict;
comment	@# @;


1.2
date	2007.08.02.16.36.18;	author thau;	state Exp;
branches;
next	1.1;

1.1
date	2007.07.25.22.05.07;	author thau;	state Exp;
branches;
next	;


desc
@@


1.2
log
@disjoint children now works with multiple roots
@
text
@from taxonomy import *
from latent_tax_assumption import *
from xmlParser import *
from utility import *
from graphViz import *
from config import *
from reasoner import *
import getopt
import sys
import os



# todo
# make the taxmap name a function of the file name
# nicer ltastring (put in ands)

#some nice arguments:
#-x Ranunculus.xml -s "Ranunculus flammula"  -t "[('Kartesz 2004','k04'),('Benson 1948','b48')]"  -w "implied" -n "('k04_buttercup10259','b48_buttercup10261')" -o happy.txt

def newTLIFile(goalType, inputFile, articulations, ltaString, inText, outputDir):
    
    # write new implied values
    artText = inText
    #fileName = inputFile[:-4] + "_" + ltaString + "_" + goalType + ".tli"
    fileName = outputDir + "tli/" + getNameFromFile(inputFile) + "_" + ltaString + "_" + goalType + ".tli"
    
    for articulation in articulations:
        thisArt = str(articulation)
        thisArt = thisArt.replace("[", "*")
        thisArt = thisArt.replace("]", "*")
        if (thisArt.find("{") == -1):
            artText += thisArt + "\n"
         
    outFile = open(fileName, "w")
    outFile.write(artText)
    outFile.close()
    #makeGraph(fileName)

def runSingleReasoner(outputDir, inputFile):
    # basically, take a file, run prover9, run mace, return results
    
    reasonerOutputDir = outputDir + "reasonerFiles/"
    if (not(os.path.exists(reasonerOutputDir))):
        os.mkdir(reasonerOutputDir)
    
    prover = Prover9(REASONERDIR, REASONERTIMEOUT)    
    mace = Mace4(REASONERDIR, REASONERTIMEOUT)
    
    proverOutput = prover.run(inputFile)
    maceOutput = mace.run(inputFile)
    
    fileName = getNameFromFile(inputFile)
    elements = fileName.split("-")
    
    return [fileName, elements[0], elements[1], proverOutput[0], maceOutput[0]]
      
        
def runDirReasoner(outputDir, inputDir):
    
    result = []
    files = os.listdir(inputDir)
    
    for inputFile in files:
        result.append(runSingleReasoner(outputDir, inputDir + "/" + inputFile))
        
    return result   
          

def runSingle(inputFile, ltaSets, goals, goalRelations, goalTypes, outputDir, outputType, outputFile, NUMBER_OUTPUT_COLS ):

    #ltaClass = LatentTaxAssumption()

    print "calling run single on " + getNameFromFile(inputFile)
   
    taxMap = TaxonomyMapping()
    taxMap.prover = Prover9(REASONERDIR, REASONERTIMEOUT)
    taxMap.mace = Mace4(REASONERDIR, REASONERTIMEOUT)
    
    taxMap.name = getNameFromFile(inputFile)
    taxMap.readFile(inputFile)
    
    result = []

    if (goals == "all"):
        goals = taxMap.getAllTaxonPairs()
        
    reasonerOutputDir = outputDir + "reasonerFiles/"
    if (not(os.path.exists(reasonerOutputDir))):
        os.mkdir(reasonerOutputDir)
        
    # for each LTA se
    #ltaSets = ltaClass.powerSet(["NonEmptiness()", "DisjointChildren()", "Coverage()"])

    for ltaSet in ltaSets:
        newImplied = []
        newPossible = []
        ltaString = ""
        for lta in ltaSet:
            if (lta != ltaSet[0]):
                ltaString += "_"    
            ltaString += str(lta)
        if ltaString == "":
            ltaString = "noLTA"
        
        # test the taxonomies, articulations and LTAs for consistency   
        taxMap.ltas = ltaSet
        # first see if the taxonomies and articulations are consistent unde
        # this LTA
        output = getNameFromFile(inputFile) + "\t"
        for taxonomy in taxMap.taxonomies.keys():
            output += taxMap.taxonomies[taxonomy].authority.abbrev + "\t"
        output += taxMap.ltaString() 

        impliedFileName = outputDir + "tli/" + getNameFromFile(inputFile) + "_" + ltaString + "_implied.tli"
        possibleFileName = outputDir + "tli/" + getNameFromFile(inputFile) + "_" + ltaString + "_possible.tli"
        consistentWithoutGoal = "not checked"
       
        #results are lists [result, [provers], [inputs], [outputs]]
        if ("consistent" in goalTypes):     
          consistencyCheck = taxMap.testConsistencyWithoutGoal(reasonerOutputDir)
  
          consistentWithoutGoal = consistencyCheck[0]
          provenance = provenanceString(consistencyCheck[1], consistencyCheck[2], consistencyCheck[3])
        
          output += "\tconsistency\t" + "\t" + impliedFileName + "\t" + possibleFileName + "\t" + "\t" + \
            consistentWithoutGoal + "\t" + provenance
          result.append(output)
        
        #if ((isConsistent == True) and (len(goalTypes) != 0))): 
        if (((consistentWithoutGoal == "not checked") or
             (consistentWithoutGoal == "true")) and 
            (("implied" in goalTypes) or ("possible" in goalTypes))):
           
            for thisGoal in goals:
                for goalRelation in goalRelations:                 
                    for goalType in goalTypes:
                        if goalType != "consistent":
                             #print goalType + " " + goalRelation + " " + str(thisGoal)
                             #goal = eval(thisGoal) goal should be an array of tuples
                             taxMap.hypothesisType = goalType
                             taxMap.hypothesis = Articulation(thisGoal[0] + " " + goalRelation + " " + thisGoal[1],taxMap)
                        
                             consistencyCheck = taxMap.testConsistencyWithGoal(reasonerOutputDir)
                        
                        
                             goalIsTrue = consistencyCheck[0]
			     source = consistencyCheck[4]
                             #print "Hypothesis " + str(taxMap.hypothesis) + " is: " + goalIsTrue
                             #if (goalIsTrue.find("stated") == -1):
                             if (1 == 1):
                        
                                 output = getNameFromFile(inputFile) + "\t"
                            
                                 for taxonomy in taxMap.taxonomies.keys():
                                     output += taxMap.taxonomies[taxonomy].authority.abbrev + "\t"
                
                                 output += taxMap.ltaString()         
                                 output += "\t" + taxMap.hypothesisType + "\t" +  source + "\t" + taxMap.hypothesis.taxon1.abbrev 
                                 output += "\t" + taxMap.hypothesis.taxon2.abbrev 
                                 output += "\t" + goalRelation
                          
                        
                                 #print "con with goal: " + consistencyCheck[0] + " " + goalType + " " + goalRelation + " " + str(thisGoal)
                        
                                 provenance = provenanceString(consistencyCheck[1], consistencyCheck[2], consistencyCheck[3])

                        
                                 #print "Checking " + taxMap.hypothesisType + " "  + taxMap.hypothesis.toLTax() + ". "
                                 if (goalIsTrue == "true"):
                                     #print "Holds under " + taxMap.ltaString() + "\n"
                                     output += "\ttrue\t" + provenance
                                     if (goalType == "implied"):
                                         newImplied.append(taxMap.hypothesis)
                                     else:
                                         newPossible.append(taxMap.hypothesis)
                                
                                 elif (goalIsTrue.find("false") != -1):
                                     #print "Does not hold under " + taxMap.ltaString() + "\n"
                                     output += "\t" + goalIsTrue + "\t" + provenance
                                 elif (goalIsTrue.find("unclear") != -1):
                                     #print "Cannot prove that it holds under " + taxMap.ltaString() + ".  But it may be the provers quitting early.\n"                                    output += "\t" + goalIsTrue + "\t"  + provenance
                                     output += "\t" + goalIsTrue + "\t" + provenance
                                 else:
                                     #print "something's wrong with the logic for " + taxMap.ltaString() + "\n"
                                     print "erronious goal is true is " + goalIsTrue
                                     output += "ERROR!"    
                                
                                 result.append(output)
                  
        outputNewTLI(inputFile, ltaSet, newImplied, newPossible, goalTypes, outputDir)

    outputResult(result, outputType, outputFile, NUMBER_OUTPUT_COLS, goalTypes, outputDir)
    

def outputNewTLI(inputFile, ltaSet, implied, possible, goalTypes, outputDir):
    
    ltaString = ""
    for lta in ltaSet:
        if (lta != ltaSet[0]):
            ltaString += "_"    
        ltaString += lta.abbrev
    if ltaString == "":
        ltaString = "noLTA"
        
    inText = ""
    inFile = open(inputFile, "r")
    inTextList = inFile.readlines() 
    for line in inTextList:
        inText += line
    
    for goalType in goalTypes:      
        newTLIFile(goalType, inputFile, implied, ltaString, inText,outputDir)
    
    
    
def provenanceString(provers, inputs, outputs):
    
    result = ""
    for index in range(len(provers)):
        if (index != 0):
            result += "\t"
        result += provers[index] + "\t" + inputs[index] + "\t" + outputs[index]
    return result
    
def runDir(inputLocation, ltaSets, goals, goalRelations, goalTypes, outputDir, outputType, outputFile, NUMBER_OUTPUT_COLS):
    
    result = []
    files = os.listdir(inputLocation)
    
    for inputFile in files:
        runSingle(inputLocation + "/" + inputFile, ltaSets, goals, goalRelations, goalTypes, outputDir, outputType, outputFile, NUMBER_OUTPUT_COLS)
              
  

def usage():
    print """May be called at the command line with the following arguments,
             or, if loaded in the python shell may be called with main() and the
             options as a list of strings (e.g. main(["-i","input.txt"])
             
             Options preceded by an asterisk are not yet implemented
             
             GENERAL OPTIONS
             -r : root directory
             -o : output file - if left out, goes to stdout
             -p : program directory - where the reasoners live
             -m : directory to store intermediate files
             -T : reasoner timeout in seconds
             
             
             TLI FILE INPUT OPTIONS
             -i : input single TLI file
             -d : input directory of TLI files
             
             REASONER INPUT OPTIONS
             -D : input directory of reasoner input files
             -I : input single reasoner file
             
             PROGRAM OUTPUT OPTIONS
             -h : html table output
             * -? : latex table output
             
             XML PARSING OPTIONS
             -x : xml file to parse into TLI files
             -s : species in the xml file, either a single species or a csv string
             -t : a list of authority/abbreviation tuples 
                 (e.g. "[('Kartesz 2004','k04'),('Benson 1948','b48')]")
             * -? : directory for the resulting TLI files, if not provided
                 they go into the intermediate files/filename directory
           
             NOTE: One of -i, -d or -x must be specified.  
             
             LTA OPTIONS
             Unless otherwise specified, no LTAs will be applied.
             
             -l : a csv string of ltas to apply, for example: "n,nc,ncd,cd,none" 
                    will run LTA sets [non-empty], [non-empty and coverage], 
                    [non-empty, coverage, and disjoint children], 
                    [coverage and disjoint children], and no LTAs
                    
             -v : a csv list of single lta and run the powerset.  For example
                     "n,c,d" will run the power set 
                     "n,c,d,nc,nd,cd,ncd and none"        
             
             
             GOAL OPTIONS
              -n : nodes to test, 
                  either "all": compare all pairwise nodes 
                  otherwise a set of tuples to test "(a,d) (b,e) (c,f)"
              *   or two csv lists, one for T1 and one for T2 "a,b,c d,e,f", 
                  
              -c : relations to test.  This is a csv list, such as:
                  "equals,{overlaps equals},overlaps,is_included_in"
                  
              -a : a powerset of relations given in a csv list     
                
              -w : test types, either "all", or comma delimited string composed of
                     consistent, implied and/or possible 
                     eg "consistent,implied" 
                     if excluded, no goals are tested (only consistency of axioms).
             """



def outputResult(resultSet, outputType, outputFileName, outputCols, goalTypes, OUTPUTDIR):

    outputFileName = cleanOutputFileName(outputFileName)
    
    if (outputFileName != "console"):
        outFile = open(outputFileName, "a")
        
    outputString = ""
        
    if (outputType == "text"):    
        for result in resultSet:
            #if (outputFileName == "console"):
            #    outputString += result
            #else: 
            outputString += result + "\n"
                
    elif (outputType == "html"):
        
        outputString = "<table border=\"1\">\n"
        for result in resultSet:
            outputString += "<tr>"
            elements = result.split("\t")
            consistencyFlag = False
            if (elements[4] == "consistency"):
                consistencyFlag = True
                
            for index in range(outputCols):
                thisElement = elements[index]
                if (consistencyFlag):
                    if (index == 6):
                        if ("implied" in goalTypes):
                            fileName = (elements[index].split(OUTPUTDIR))[1]
                            impliedGraph = fileName[:-3] + "gif"
                            impliedGraph = impliedGraph.replace("tli","figures")
                            thisElement = "<a href=\"file:" + fileName + "\">Implied</a> <a href=\"file:" + impliedGraph + "\">figure</a>" 
                        else:
                            thisElement = ""
                    elif (index == 7):
                        if ("possible" in goalTypes):
                            fileName = (elements[index].split(OUTPUTDIR))[1]
                            possibleGraph = fileName[:-3] + "gif"
                            possibleGraph = possibleGraph.replace("tli","figures")
                            thisElement = "<a href=\"file:" + fileName + "\">Possible</a> <a href=\"file:" + possibleGraph + "\">figure</a>" 
                        else:
                            thisElement = ""
                outputString += "<td>" + thisElement + "</td>"
 
            for reasonerIndex in range(outputCols, len(elements), 3):
                reasonerName = elements[reasonerIndex]
		reasonerInput = ""
		reasonerOutput = ""
                if (reasonerInput.find(OUTPUTDIR) != -1): 
                	reasonerInput = (elements[reasonerIndex+1].split(OUTPUTDIR))[1]
                if (reasonerOutput.find(OUTPUTDIR) != -1): 
                	reasonerOutput = (elements[reasonerIndex+2].split(OUTPUTDIR))[1]
                outputString += "<td>"
                outputString += "<a href=\"file:" + reasonerInput + "\">" + reasonerName + " input file</a>"
                outputString += "</td>"
                outputString += "<td>"
                outputString += "<a href=\"file:" + reasonerOutput + "\">" + reasonerName + " output file</a>"
                outputString += "</td>"

            outputString += "</tr>\n"
        outputString += "</table>"
            
                    
    if (outputFileName == "console"):
        print outputString;
    else: 
        outFile.write(outputString)
        outFile.close()
        
def main(optInfo):

    # set default values
    #
    #ROOT = "/home/thau/research/taxaLogic/"
    #OUTPUTDIR = ROOT + "output/"
    #REASONERDIR= "/home/thau/applications/bin/"
    NUMBER_OUTPUT_COLS = 10  # this is the number of output columns in common to all runs
    TAXONOMIES = [("Kartesz 2004","k04"),("Benson 1948","b48"),("Jepson 1993","j93")]
    
    try:
        opts, args = getopt.getopt(optInfo, "a:c:d:D:i:I:l:m:n:o:p:r:s:t:T:v:w:x:h")
    except getopt.GetoptError:
        # print help information and exit:
        usage()
        sys.exit(1)
    
    global ROOT
    global OUTPUTDIR
    global REASONERDIR
    global REASONERTIMEOUT
    
    inputLocation = ""
    inputType = ""
    result = ""
    outputType = "text"
    outputFile = "console"
    taxonomies = []
    species = []
    goals = []

    ltaList = []
    goalTypes = []
    goalRelations = ["includes","equals","disjoint","overlaps","is_included_in"]
    ltaString = ""
    ltas = LatentTaxAssumption()
    
   
    for o, a in opts:
        if o == "-r":
            ROOT = a
        elif o == "-m":
            if (a[:-1] != "/"):
                a = a + "/"     
            OUTPUTDIR = a
        elif o == "-o":
            outputFile = a
        elif o == "-p":
            REASONERDIR = a
        elif o == "-i":
            inputType = "single"
            inputLocation = ROOT + a
        elif o == "-d":
            inputType = "directory"
            inputLocation = ROOT + a
        elif o == "-I":
            inputType = "single_reasoner"
            inputLocation = ROOT + a
        elif o == "-D":
            inputType = "directory_reasoner"
            inputLocation = ROOT + a     
        elif o == "-h":
            outputType = "html"
        elif o == "-x":
            inputType = "xml"
            inputLocation = ROOT + a
        elif o == "-t":
            taxonomies = eval(a)
        elif o == "-T":
            REASONERTIMEOUT = a
        elif o == "-s":
            species = a.split(",")
        elif o == "-l":
            ltaList = ltas.getLTAsFromString(a)
        elif o == "-c":
            goalRelations = a.split(",")
        elif o == "-a":
            goalRelations = []
            subRelations = a.split(",")
            allRelations = powerSet(subRelations)
            for powerRelation in allRelations:
                if len(powerRelation) > 1:
                    thisRel = "{" + " ".join(powerRelation) + "}"
                    goalRelations.append(thisRel)
                elif len(powerRelation) == 1: 
                    thisRel = powerRelation[0]
                    goalRelations.append(thisRel)
                  
        elif o == "-w":
            if (a == "all"):
                goalTypes = ["consistent","possible","implied"]
            else:
                goalTypes = a.split(",")
        elif o == "-n":
            if (a == "all"):
                goals = "all"
            else:
            # goals now should either be a string like "(a,b) (c,d)" or nothing
            # the result should be a list of tuples
                stringGoals = a.split(" ")
                goals = []
                for goal in stringGoals:
                    goals.append(eval(goal))   
        elif o == "-v":
            myList = []
            theseLTAs = a.split(",")
            for thisLTA in theseLTAs:
                myList.append(ltas.getLTAFromAbbrev(thisLTA))
            ltaList = powerSet(myList)
              
    if (len(ltaList) == 0):
        ltaList = [[]]
    #    ltaList = ltas.powerSet()
            
    if (outputFile != "console"):
        outputFile = OUTPUTDIR + outputFile
                
    if (not(os.path.exists(OUTPUTDIR))):
        os.mkdir(OUTPUTDIR)

    tliDir = OUTPUTDIR + "tli/"
    if (not(os.path.exists(tliDir))):
        os.mkdir(tliDir)

    if (len(taxonomies) == 0):
        taxonomies = TAXONOMIES

                 
    if (inputType == ""):
        usage()
        #sys.exit(2)
    elif (inputType == "xml"):               
        parsedTLIs = parseXML(inputLocation, taxonomies, species, OUTPUTDIR)
        runDir(parsedTLIs, ltaList, goals, goalRelations, goalTypes, OUTPUTDIR, outputType, outputFile, NUMBER_OUTPUT_COLS)
    elif (inputType == "single"):
        runSingle(inputLocation, ltaList, goals, goalRelations, goalTypes, OUTPUTDIR, outputType, outputFile, NUMBER_OUTPUT_COLS)
    elif (inputType == "directory"):
        runDir(inputLocation, ltaList, goals, goalRelations, goalTypes, OUTPUTDIR, outputType, outputFile, NUMBER_OUTPUT_COLS)
    elif (inputType == "single_reasoner"):
        print runSingleReasoner(OUTPUTDIR,inputLocation)
    elif (inputType == "directory_reasoner"):
        result = runDirReasoner(OUTPUTDIR,inputLocation)
        for item in result:
            print ",".join(item) 
        
    #outputResult(result, outputType, outputFile, NUMBER_OUTPUT_COLS, goalTypes, OUTPUTDIR)

    

if __name__ == "__main__":
    if len(sys.argv) > 1:
        optInfo = sys.argv[1:]
        main(optInfo)
    else:
        usage()

  













@


1.1
log
@moving files around
@
text
@d138 5
a142 4
                        #print goalType + " " + goalRelation + " " + str(thisGoal)
                        #goal = eval(thisGoal) goal should be an array of tuples
                        taxMap.hypothesisType = goalType
                        taxMap.hypothesis = Articulation(thisGoal[0] + " " + goalRelation + " " + thisGoal[1],taxMap)
d144 1
a144 1
                        consistencyCheck = taxMap.testConsistencyWithGoal(reasonerOutputDir)
d147 5
a151 5
                        goalIsTrue = consistencyCheck[0]
			source = consistencyCheck[4]
                        #print "Hypothesis " + str(taxMap.hypothesis) + " is: " + goalIsTrue
                        #if (goalIsTrue.find("stated") == -1):
                        if (1 == 1):
d153 1
a153 1
                            output = getNameFromFile(inputFile) + "\t"
d155 2
a156 2
                            for taxonomy in taxMap.taxonomies.keys():
                                output += taxMap.taxonomies[taxonomy].authority.abbrev + "\t"
d158 4
a161 4
                            output += taxMap.ltaString()         
                            output += "\t" + taxMap.hypothesisType + "\t" +  source + "\t" + taxMap.hypothesis.taxon1.abbrev 
                            output += "\t" + taxMap.hypothesis.taxon2.abbrev 
                            output += "\t" + goalRelation
d164 1
a164 1
                            #print "con with goal: " + consistencyCheck[0] + " " + goalType + " " + goalRelation + " " + str(thisGoal)
d166 1
a166 1
                            provenance = provenanceString(consistencyCheck[1], consistencyCheck[2], consistencyCheck[3])
d169 8
a176 8
                            #print "Checking " + taxMap.hypothesisType + " "  + taxMap.hypothesis.toLTax() + ". "
                            if (goalIsTrue == "true"):
                                #print "Holds under " + taxMap.ltaString() + "\n"
                                output += "\ttrue\t" + provenance
                                if (goalType == "implied"):
                                    newImplied.append(taxMap.hypothesis)
                                else:
                                    newPossible.append(taxMap.hypothesis)
d178 10
a187 10
                            elif (goalIsTrue.find("false") != -1):
                                #print "Does not hold under " + taxMap.ltaString() + "\n"
                                output += "\t" + goalIsTrue + "\t" + provenance
                            elif (goalIsTrue.find("unclear") != -1):
                                #print "Cannot prove that it holds under " + taxMap.ltaString() + ".  But it may be the provers quitting early.\n"                                    output += "\t" + goalIsTrue + "\t"  + provenance
                                output += "\t" + goalIsTrue + "\t" + provenance
                            else:
                                #print "something's wrong with the logic for " + taxMap.ltaString() + "\n"
                                print "erronious goal is true is " + goalIsTrue
                                output += "ERROR!"    
d189 1
a189 1
                            result.append(output)
@

